"""Polygon class for core."""
import itertools

import numpy as np

from .abstract_geometry import ABCGeo
from .point import Point


class Polygon(ABCGeo):
    """
    Polygon core class.

    Warning:
        The points property returns the actual list reference.
        Modifying this list directly will affect the polygon.
        For safe operations, use the provided methods.

    """

    CHECK_ON_CONVEX = False

    def __init__(self, points: list[Point]) -> None:
        """
        Initialize 2D polygon.

        Point is a vertex of polygon.

        Args:
            points: list of Point objects

        Raises:
            TypeError if any point in points list is not Point type
            ::Optional:: ValueError if points do not form convex figure
                This check will occur if CHECK_ON_CONVEX constant is True

        """
        Point.check_point_instance(*points)
        Polygon._raise_if_not_convex(self._ensure_closed(points))
        self._points = points.copy()

    def _ensure_closed(self, points: list[Point]) -> list[Point]:
        """
        Ensure that start point is equal to the end point.
        """
        if points[0] != points[-1]:
            return [*points, points[0]]
        return points.copy()

    def save(self) -> str:
        """
        Return JSON string representation of the object.
        """
        points = [point.save() for point in self.points]
        return "; ".join(points)

    @classmethod
    def load(cls, data: str) -> "Polygon":
        """
        Create object from JSON string.

        Args:
            data: JSON string generated by save() method

        Returns:
            New instance of the class.

        """
        points = [Point.load(point) for point in data.split("; ")]
        return cls(points)

    @property
    def points(self) -> list[Point]:
        """
        Return list of vertices of polygon.
        """
        return self._ensure_closed(self._points)

    @points.setter
    def points(self, new_points: list[Point]) -> None:
        """
        Set vertices to polygon.

        Args:
            new_points: new coordinates(points) of vertices

        Raises:
            TypeError if any point in new_points list is not Point type
            ::Optional:: ValueError if points do not form convex figure
                This check will occur if CHECK_ON_CONVEX constant is True

        """
        Point.check_point_instance(*new_points)
        Polygon._raise_if_not_convex(self._ensure_closed(new_points))
        self._points = new_points.copy()

    def __str__(self) -> str:
        """
        Return string representation of Polygon.
        """
        return "[" + " ".join([str(point) for point in self.points]) + "]"

    def insert_point(self, point: Point, pos: int) -> None:
        """
        Add point in the end of list.

        Raises:
            TypeError point parameter is not Point type
            ::Optional:: ValueError if points after changing do not form convex figure
                This check will occur if CHECK_ON_CONVEX constant is True

        """
        if pos >= 0:
            temp_points = self._points.copy()
            temp_points.insert(pos, point)
            self.points = temp_points           #double copying, cause checks occur in points setter

    @staticmethod
    def check_on_convex(points: list[Point]) -> bool:
        """
        Check if polygon is convex.

        Args:
            points: list of points that form polygon

        Returns:
            bool variable:
                True if points form convex polygon
                False otherwise

        """
        sides = list(itertools.pairwise(points))
        pair_sides = list(itertools.pairwise(sides))
        reference_vector = np.array([0, 0, 1])

        def get_sign(side1: Point, side2: Point) -> int:
            vec1 = np.array([side1[1].x - side1[0].x, side1[1].y - side1[0].y, 0])
            vec2 = np.array([side2[1].x - side2[0].x, side2[1].y - side2[0].y, 0])
            return np.sign(np.inner(np.cross(vec1, vec2), reference_vector))

        sign = get_sign(*pair_sides[0])
        return all(get_sign(side1, side2) == sign for side1, side2 in pair_sides)

    @staticmethod
    def _raise_if_not_convex(points: list[Point]) -> None:
        """
        Check if polygon is convex.

        Args:
            points: list of points that form polygon

        Raises:
            ValueError: if data is incorrect.

        """
        if Polygon.CHECK_ON_CONVEX and not Polygon.check_on_convex(points):
            error_msg = "points do not form convex polygon"
            raise ValueError(error_msg)

    def __getitem__(self, index: int) -> Point:
        """
        Allow to get element through '[]'.
        """
        return self._points[index]

    def __setitem__(self, index: int, point: Point) -> None:
        """
        Allow to set new value through '[]'.

        Raises:
            TypeError point parameter is not Point type
            ::Optional:: ValueError if points after changing do not form convex figure
                This check will occur if CHECK_ON_CONVEX constant is True

        """
        if 0 <= index < len(self._points):
            self.points[index] = point
            temp_points = self._points.copy()
            temp_points[index] = point
            self.points = temp_points           #double copying, cause checks occur in points setter
