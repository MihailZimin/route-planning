"""Arc class for core."""
import json
import math

from .abstract_geometry import ABCGeo
from .point import Point


class Arc(ABCGeo):
    """
    Arc core class.
    """

    def __init__(self, center: Point, p_start: Point, p_end: Point, precision: float = 1e-5) -> "Arc":
        """
        Return Arc object, constructed by 3 points.

        Constructed by center, start and end point of Arc,
        arc formed counterclockwise from start point to end point.

        Args:
            center: coordinate(point) of center of Arc
            p_start: coordinate(point) of start of Arc
            p_end: coordinate(point) of end of Arc
            precision: precision of difference in possible radius

        Returns:
            Arc: New Arc instance with such fields as:
                center: center of Arc
                p_start: coordinate(point) of start of Arc
                p_end: coordinate(point) of end of Arc
                angle1: angle in radians between center-to-top-point line and center-to-p_start line
                angle2: angle in radians between center-to-top-point line and center-to-p_end line
                radius: radius of Arc

        """
        self.__errormsg = ("Invalid input points, distance between"
                         "center and first point is not equal to"
                         "distance between center and second point")
        self._precision = precision

        radius = center.distance_to(p_start)
        self._radius = radius
        self._center = center
        if not self.__compare_radius_and_distance(p_end):
            raise ValueError(self.__errormsg)

        self._a_start = math.acos((p_start.y - center.y) / radius)
        if (p_start.x < center.x):
            self._a_start = 2 * math.pi - self._a_start
        self._a_end = math.acos((p_end.y - center.y) / radius)
        if (p_end.x < center.x):
            self._a_end = 2 * math.pi - self._a_end
        self._p_start = p_start
        self._p_end = p_end


    @classmethod
    def from_angle(
        cls,
        center: Point,
        radius: float,
        angle_start: float,
        angle_end: float,
        precision: float = 1e-5
    ) -> "Arc":
        """
        Initialize Arc with radius, center point and angle.

        Constructed by center, radius, angle_start and angle_end point of Arc,
        arc formed counterclockwise from start angle to end angle.

        Args:
            center: Center point of the arc
            radius: Radius of the arc
            angle_start: Angle of the start angle in radians
            angle_end: Angle of the end angle in radians
            precision: precision of difference in possible radius

        Returns:
            Arc: New Arc instance with such fields as:
                center: center of Arc
                p_start: coordinate(point) of start of Arc
                p_end: coordinate(point) of end of Arc
                angle_start: angle in radians between center-to-top-point line and center-to-p_start line
                angle_end: angle in radians between center-to-top-point line and center-to-p_end line
                radius: radius of Arc

        """
        p_start = Point()
        p_start.x = center.x + radius * math.sin(angle_start)
        p_start.y = center.y + radius * math.cos(angle_start)

        p_end = Point()
        p_end.x = center.x + radius * math.sin(angle_end)
        p_end.y = center.y + radius * math.cos(angle_end)

        return cls(center, p_start, p_end, precision)

    def save(self) -> str:
        """
        Return JSON string representation of the object.
        """
        center_str = f'[{self._center.x}, {self._center.y}]'

        return (
        '{\n'
        f'    "center": {center_str},\n'
        f'    "radius": {self._radius},\n'
        f'    "a_start": {self._a_start},\n'
        f'    "a_end": {self._a_end},\n'
        f'    "precision": {self._precision}\n'
        '}'
    )

    @classmethod
    def load(cls, json_data: str) -> "Arc":
        """
        Create object from JSON string.

        Args:
            json_data: JSON string generated by save() method

        Returns:
            New instance of the class.

        """
        data = json.loads(json_data)
        return cls.from_angle(
            Point.load(str(data["center"])),
            data["radius"],
            data["a_start"],
            data["a_end"],
            data["precision"],
        )

    @property
    def radius(self) -> float:
        """
        Return radius of the arc.
        """
        return self._radius

    @radius.setter
    def radius(self, new_radius: float) -> None:
        """
        Set radius of the arc.

        Also change position of points according to new radius.

        Args:
            new_radius: new radius value

        """
        self._radius = new_radius
        self.__adjust_start_point()
        self.__adjust_end_point()

    @property
    def center(self) -> Point:
        """
        Return center point of the arc.
        """
        return self._center

    @center.setter
    def center(self, new_center: Point) -> None:
        """
        Set center point of the arc.

        Also change position of points according to new center.

        Args:
            new_center: new center point

        """
        self._center = new_center
        self.__adjust_start_point()
        self.__adjust_end_point()

    @property
    def a_start(self) -> float:
        """
        Return the angle of the arc in radians.
        """
        return self._a_start

    @property
    def a_end(self) -> float:
        """
        Return the angle of the arc in radians.
        """
        return self._a_end

    @property
    def p_start(self) -> Point:
        """
        Return start point.
        """
        return self._p_start

    @p_start.setter
    def p_start(self, new_start: Point) -> None:
        """
        Set start point.

        Also change start angle value according to new start point position.

        Args:
            new_start: new start position in radians.

        """
        if not self.__compare_radius_and_distance(new_start):
            raise ValueError(self.__errormsg)

        self._p_start = new_start
        self._a_start = math.acos((self._p_start.y - self._center.y) / self._radius)
        if (self._p_start.x < self._center.x):
            self._a_start = 2 * math.pi - self._a_start

    @property
    def p_end(self) -> Point:
        """
        Return end point.
        """
        return self._p_end

    @p_end.setter
    def p_end(self, new_end: Point) -> None:
        """
        Set end point.

        Also change end angle value according to new end point position.

        Args:
            new_end: new end position in radians.

        """
        if not self.__compare_radius_and_distance(new_end):
            raise ValueError(self.__errormsg)

        self._p_end = new_end
        self._a_end = math.acos((self._p_end.y - self._center.y) / self._radius)
        if (self._p_end.x < self._center.x):
            self._a_end = 2 * math.pi - self._a_end

    @property
    def precision(self) -> float:
        """
        Return eps_precision.
        """
        return self._precision

    @precision.setter
    def precision(self, new_precision: float) -> None:
        """
        Set precision.

        Args:
            new_precision: new precision.

        """
        self._precision = new_precision

    def __adjust_start_point(self) -> None:
        """
        Adjust start point coordinates according to changes.
        """
        self._p_start.x = self._center.x + self._radius * math.sin(self._a_start)
        self._p_start.y = self._center.y + self._radius * math.cos(self._a_start)

    def __adjust_end_point(self) -> None:
        """
        Adjust end point coordinates according to changes.
        """
        self._p_end.x = self._center.x + self._radius * math.sin(self._a_end)
        self._p_end.y = self._center.y + self._radius * math.cos(self._a_end)

    def __str__(self) -> str:
        """
        Return string representation.
        """
        return self.save()

    def __compare_radius_and_distance(self, point: Point) -> bool:
        """
        Compare distance between center and point with radius of arc.

        Args:
            point: point which distance to center we want to compare.

        Returns:
            True if difference lower than eps_precision
            False otherwise

        """
        return math.isclose(self._center.distance_to(point), self._radius, rel_tol=self._precision)
